<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ME 405 Romi Term Project: ME 405 Romi Term Project</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ME 405 Romi Term Project
   </div>
   <div id="projectbrief">The source code for the Romi term project in ME 405, Mechatronics.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">ME 405 Romi Term Project </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="ss_intro"></a>
Introduction &amp; Challenge</h1>
<p>The ME 405 Romi Term Project library contains the source code for Joseph Penrose &amp; Paolo Navarro's ME 405 Mechatronics term project. The project is built on the Pololu Romi robot kit, the ME 405 Mechatronics Python code library written by Dr. JR Ridgely, and MicroPython.</p>
<p>The ME 405 Mechatronics term project is designed to challenge the students' ability to write real-time, microcontroller-based programming integrating multiple sensors and actuators at once. The game board is a table-sized white paper with a maze drawn on it with black ink and 3/4" wide lines, that may include turns, dashes, and cross-hatches. Romi must follow the lines
    from the start to the finish. There is also an obstacle, an 8" by 8" by 8" cube, somewhere on the track that Romi must avoid. Once Romi reaches the finish line, it must return to the start by any means.</p>
<p>[example track]</p>
<p>Students are responsible for any mechanical design, sensor choice and integration, and programming required to complete the challenge.</p>
<p>[romi photo]</p>
<h1><a class="anchor" id="ss_strat"></a>
Strategy</h1>
<h2><a class="anchor" id="ss_line"></a>
Line Following</h2>
<p>Romi uses an array of Pololu QTR reflectance sensors with analog output for line detection. The sensors produce an analog signal corresponding to the reflectance of the surface in view. For our purposes, the sensors produce voltages on the order of 0.2V for white paper and 2.3V for black lines (about 0.1V below Vdd). Romi's main line sensors are located on the front of the chassis, spaced [~~~~~] apart. Romi reads each sensor and multiplies each value by a weight, corresponding to the side and distance from center. Sensors on Romi's left are negative and vice versa. Sensors further from center are weighted higher. Then, summing all sensor readings together produces a signed number whose sign indicates Romi's direction off-center and whose magnitude grows as Romi gets further off the line. Then, in Romi's line-following routine, the sensor value is used with a closed-loop controller targeting a zero value (zero being on center). The output of this controller is used to differentially adjust the speed of each wheel. If Romi determines the line is to the right, then the left wheel speeds up and the right wheel slows down. This causes Romi to veer off of the straight path and turn slightly right, and tries to realign the track to the center of the chassis. If the line is to the right, the opposite occurs. In addition, Romi keeps track of the <em>unsigned</em> sum of all sensors as a check. If Romi is completely off of the line and all sensors lose signal, then it appears to the line-follower that Romi is centered because the weighted sensor value is near zero. However, the unsigned sum is used to determine if no sensors are reading line, and if so, Romi can determine if it has completely lost the track or not. If Romi determines that it has lost sight of the track, it applies a constant reading to the line-following controller corresponding to the last non-zero value to determine direction.</p>
<p>[line sensor image]</p>
<h2><a class="anchor" id="ss_obst"></a>
Obstacle Detection</h2>
<p>Romi uses a LIDAR-based distance sensor from Pololu (item # 4064) for obstacle detection. The sensor outputs a pulse-width modulation (PWM) signal, whose high-side pulse-width can be used to calculate the measured distance. Romi uses a hardware interrupt triggered by both rising- and falling-edges in order to handle the pulse measurement. Then, a task runs regularly to capture the last pulse-width measurement and calculate the most recent distance reading. The sensor has a useful working distance of 50cm according to Pololu, but tests using the lab lighting conditions and obstacle materials showed that we could reliably measure distance from the obstacele from about 20cm to 10mm. Romi simply keeps an eye on this distance value and throws up a flag when the obstacle is spotted a short distance straight ahead. We trust that the approx. 15 degree viewing angle is tight enough to only detect the obstacle when it is straight ahead on the track, and not from an inappropriate position somewhere else on the track. When the obstacle is detected, Romi runs through a hard-coded avoidance path. The size of the obstacle is known, and this is a rules-accepted method of passing the obstacle.</p>
<p>[distance sensor image]</p>
<h2><a class="anchor" id="ss_fnsh"></a>
Finish Line Detection</h2>
<p>The track's start and finish lines are distinct from the rest of the track because they are the only line pattern on the track where the line abtruptly ends and a horizontal line crosses completely across the width of the robot. This is another use of the unsigned sensor value, which is used to detect if all sensors go off at once. If they do, and then abruptly all go dark, Romi assumes it has crossed the finish line.</p>
<h2><a class="anchor" id="ss_dead"></a>
Dead Reckoning and World Position</h2>
<p>Romi uses a dead reckoning system that blends IMU and encoder data to constantly record Romi's position in world coordinates, where the initial position on startup is considered (X,Y) (0,0) and heading phi = 0. Romi considers the direction straight ahead as +X, and to the left through the center of the wheel axes as +Y. Heading phi is considered a rotation about the Z-axis in standard coordinates, where the direction of the +X-axis is 0 and the +Y-axis is pi/2 rad, etc. Romi resets at 2pi rad when crossing back over the +X-axis.</p>
<p>The dead reckoning system works on three key assumptions: </p><ul>
<li>
For a small timestep, Romi takes perfectly circular or perfectly straight paths. </li>
<li>
For a small timestep, Romi's wheel speeds remain constant. </li>
<li>
Romi's tires do not slip. </li>
</ul>
<p>The first two assumptions are based on the differential-drive system. If both wheels move at the same speed, then Romi moves in a straight line. If the wheels have different speeds, then Romi's path can be represented by two arcs corresponding by the individual paths taken by each wheel. For a small timestep, if the wheel speeds are constant, then they will trace perfectly circular arcs on the ground, and geometry can be used to find the distance and direction between start and end points.</p>
<p>[derivation &amp; images]</p>
<h1><a class="anchor" id="ss_comp"></a>
Component Overview</h1>
<h2><a class="anchor" id="ss_romi"></a>
Romi</h2>
<p>Romi is a small, differential-drive robot kit produced by Pololu, an American educational electronics and robotics company. Romi's chassis is circular, roughly 6" in diameter, and driven by two DC gearmotors on 70mm wheels. It is balanced on front and rear ball casters. Pololu provides the bare bones of the robot: the chassis, wheels, motors with encoders, and a power mainboard that interfaces with 6x AA batteries with connections.</p>
<h2><a class="anchor" id="ss_mcu"></a>
Microcontroller: STM32 Nucleo &amp; The Shoe Of Brian</h2>
<p>Romi's brain consists of a STMicroelectronics Nucleo-L476RG microcontroller board and an ME 405 Shoe Of Brian, an add-on board created by Dr. JR Ridgely for Mechatronics students. The Shoe Of Brian provides direct USB access to the flash memory on the Nucleo and allows for MicroPython scripts to be loaded directly onto the Nucleo without a flasher. It is also used for easy access to the REPL command line over serial for direct communication.</p>
<p>For the offical Shoe of Brian documentation, see <a href="https://spluttflob.github.io/ME405-Support/index.html">https://spluttflob.github.io/ME405-Support/index.html</a></p>
<h2><a class="anchor" id="ss_pyb"></a>
MicroPython &amp; cotask/task_share</h2>
<p>All programming on Romi was created using MicroPython, a derivative of Python that is designed specifically for microcontrollers like the STM32. It contains built-in libraries for hardware-specific functions necessary to fully utilitze the STM32. It also differs from Python in that it is compiled, not interpreted. The reason for using pre-compiled Python is for speed, which makes real-time programming possible.</p>
<p>We also took advantage of the cotask &amp; <a class="el" href="namespacetask__share.html">task_share</a> classes provided by the ME 405 Python code library. cotask implements cooperative multitasking with a task scheduler. Tasks are written as generator functions, which the cotask scheduler calls over and over based on priority or round-robin scheduling. <a class="el" href="namespacetask__share.html">task_share</a> is a class that implements special data exchanges designed specifically for cotask. These classes are optimized in C and are, just like everything else, designed for speed. Cooperative multitasking and real-time programming are completely dependent on very short snippets of code, giving each other time to run when necessary. All of Romi's source code was written with this in mind.</p>
<p>For the offical ME 405 Python library documentation, see <a href="https://spluttflob.github.io/ME405-Support/annotated.html">https://spluttflob.github.io/ME405-Support/annotated.html</a></p>
<h2><a class="anchor" id="ss_pins"></a>
Romi Pin Connections</h2>
<p>Romi's pin connections are listed here for reference, with the STM32 pin names and wire colors used in the project.</p>
<p>Drive Left: </p><ul>
<li>
Motor_Dir: PB5 (blue) </li>
<li>
Motor_Eff: PB4 (green) </li>
<li>
Enc_Ch1: PA5 (yellow) <br  />
 </li>
<li>
Enc_Ch2: PB3 (blue) </li>
</ul>
<p>Drive Right: </p><ul>
<li>
Motor_Dir: PA1 (blue) </li>
<li>
Motor_Eff: PA0 (green) </li>
<li>
Enc_Ch1: PB6 (yellow) </li>
<li>
Enc_Ch2: PB7 (blue) </li>
</ul>
<p>I2C Ch 1 for <a class="el" href="namespace_b_n_o.html">BNO</a>: </p><ul>
<li>
SCL: PB8 (blue) </li>
<li>
SDA: PB9 (yellow) </li>
</ul>
<p>Axial Line Sensors: </p><ul>
<li>
L2: PC2 (blue) # Far left </li>
<li>
L1: PC3 (green) # Mid left </li>
<li>
C: PA4 (gray) # Center, Arduino pin A2 </li>
<li>
R1: PB0 (orange) # Mid right, Arduino pin A3 </li>
<li>
R2: PC1 (purple) # Far right, Arduino pin A4 </li>
</ul>
<p>Front Line Sensors: </p><ul>
<li>
FL2: PA6 (blue) # Far left <br  />
 </li>
<li>
FL1: PA7 (green) # Mid left </li>
<li>
FC: PC4 (white) # Center </li>
<li>
FR1: PA3 (orange) # Mid right </li>
<li>
FR2: PA2 (purple) # Far right </li>
</ul>
<p>Lidar: </p><ul>
<li>
Lidar: PC0 (white) </li>
</ul>
<h2><a class="anchor" id="ss_pybflash"></a>
PYBFLASH</h2>
<p>The USB connection through a Shoe Of Brian provides access to the STM32 flash memory as a USB storage device named 'PYBFLASH'. The source code contained in the PYBFLASH folder must be copied to Romi through this drive in order to run it. It runs automatically when the Nucleo powers up. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
