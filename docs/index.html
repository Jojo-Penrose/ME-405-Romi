<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ME 405 Romi Term Project: ME 405 Romi Term Project</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ME 405 Romi Term Project
   </div>
   <div id="projectbrief">The source code for the Romi term project in ME 405, Mechatronics, Fall 2023.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">ME 405 Romi Term Project </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="ss_intro"></a>
Introduction &amp; Challenge</h1>
<p>The ME 405 Romi Term Project library contains the source code for Joseph Penrose &amp; Paolo Navarro's ME 405 Mechatronics term project. The project is built on the Pololu Romi robot kit, the ME 405 Mechatronics Python code library written by Dr. JR Ridgely, and MicroPython.</p>
<p>The ME 405 Mechatronics term project is designed to challenge the students' ability to write real-time, microcontroller-based programming integrating multiple sensors and actuators at once. The game board is a table-sized white paper with a maze drawn on it with black ink and 3/4" wide lines, that may include turns, dashes, and cross-hatches. Romi must follow the lines
    from the start to the finish. There is also an obstacle, an 8" by 8" by 8" cube, somewhere on the track that Romi must avoid. Once Romi reaches the finish line, it must return to the start by any means.</p>
<div class="image">
<img src="img\track.jpg" alt="" width="60%"/>
</div>
<p>Students are responsible for any mechanical design, sensor choice and integration, and programming required to complete the challenge.</p>
<div class="image">
<img src="img\romi.jpg" alt="" width="60%"/>
</div>
<h1><a class="anchor" id="ss_gith"></a>
GitHub &amp; Project Repository</h1>
<p>To view the full project repository, including 3D models for the added Romi hardware, visit the GitHub main page at: <a href="https://github.com/Jojo-Penrose/ME-405-Romi/tree/main">https://github.com/Jojo-Penrose/ME-405-Romi/tree/main</a></p>
<h1><a class="anchor" id="ss_strat"></a>
Strategy</h1>
<h2><a class="anchor" id="ss_line"></a>
Line Following</h2>
<p>Romi uses an array of Pololu QTR reflectance sensors with analog output for line detection. The sensors produce an analog signal corresponding to the reflectance of the surface in view. For our purposes, the sensors produce voltages on the order of 0.2V for white paper and 2.3V for black lines (about 0.1V below Vdd). Romi's five line sensors are located on the front of the chassis, spaced 17mm apart. Romi reads each sensor and multiplies each value by a weight, corresponding to the side and distance from center. Sensors on Romi's left are negative and vice versa. Sensors further from center are weighted higher. Then, summing all sensor readings together (ignoring the center) produces a signed number whose sign indicates Romi's direction off-center and whose magnitude grows as Romi gets further off the line. Then, in Romi's line-following routine, the sensor value is used with a closed-loop controller targeting a zero value (zero being on center). The output of this controller is used to differentially adjust the speed of each wheel. If Romi determines the line is to the right, then the left wheel speeds up and the right wheel slows down. This causes Romi to veer off of the straight path and turn slightly right, and tries to realign the track to the center of the chassis. If the line is to the right, the opposite occurs. In addition, Romi keeps track of the <em>unsigned</em> sum of all sensors (including center) as a check. If Romi is completely off of the line and all sensors lose signal, then it appears to the line-follower that Romi is centered because the weighted sensor value is near zero. However, the unsigned sum is used to determine if no sensors are reading line, and if so, Romi can determine if it has completely lost the track or not. If Romi determines that it has lost sight of the track, it applies a constant reading to the line-following controller corresponding to the last non-zero value to determine direction.</p>
<p>A sensor array was also attached to Romi's center along the wheel axis, but it was determined to be a poor location for line sensing and is not used on the final project.</p>
<div class="image">
<img src="img\sensors.jpg" alt="" width="60%"/>
</div>
<h2><a class="anchor" id="ss_obst"></a>
Obstacle Detection</h2>
<p>Romi uses a LIDAR-based distance sensor from Pololu (item # 4064) for obstacle detection. The sensor outputs a pulse-width modulation (PWM) signal, whose high-side pulse-width can be used to calculate the measured distance. Romi uses a hardware interrupt triggered by both rising- and falling-edges in order to handle the pulse measurement. Then, a task runs regularly to capture the last pulse-width measurement and calculate the most recent distance reading. The sensor has a useful working distance of 50cm according to Pololu, but tests using the lab lighting conditions and obstacle materials showed that we could reliably measure distance from the obstacele from about 20cm to 10mm. Romi simply keeps an eye on this distance value and throws up a flag when the obstacle is spotted a short distance straight ahead. We trust that the approx. 15 degree viewing angle is tight enough to only detect the obstacle when it is straight ahead on the track, and not from an inappropriate position somewhere else on the track. When the obstacle is detected, Romi runs through a hard-coded avoidance path. The size of the obstacle is known, and this is a rules-accepted method of passing the obstacle.</p>
<div class="image">
<img src="img\dist.jpg" alt="" width="60%"/>
</div>
<h2><a class="anchor" id="ss_fnsh"></a>
Finish Line Detection</h2>
<p>The track's start and finish lines are distinct from the rest of the track because they are the only line pattern on the track where the line abtruptly ends and a horizontal line crosses completely across the width of the robot. This is another use of the unsigned sensor value, which is used to detect if all sensors go off at once. If they do, and then abruptly all go dark, Romi assumes it has crossed the finish line.</p>
<h2><a class="anchor" id="ss_dead"></a>
Dead Reckoning &amp; World Position</h2>
<p>Romi uses a dead reckoning system that blends IMU and encoder data to constantly record Romi's position in world coordinates, where the initial position on startup is considered (X,Y) (0,0) and heading phi = 0. Romi considers the direction straight ahead as +X, and to the left through the center of the wheel axis as +Y. Heading phi is considered a rotation about the Z-axis in standard radians, where the direction of the +X-axis is 0 and the +Y-axis is \(\pi / 2\) rad, etc. Romi's heading resets to 0 at \(2 \pi\) rad when crossing back over the +X-axis.</p>
<p>The dead reckoning system works on three key assumptions: </p><ul>
<li>
For a small timestep, Romi takes perfectly circular or perfectly straight paths. </li>
<li>
For a small timestep, Romi's wheel speeds remain constant. </li>
<li>
Romi's tires do not slip. </li>
</ul>
<p>The first two assumptions are based on the differential-drive system. If both wheels move at the same speed, then Romi moves in a straight line. In a straight line maneuver, dead reckoning the change in position is as simple as reading the distance run by each wheel, using the average of the two to account for error, and using the IMU heading to determine the X- and Y-components of the change in world position. If the wheels have different speeds, then Romi's path can be represented by two arcs corresponding to the individual paths taken by each wheel. For a small timestep, if the wheel speeds are constant, then they will trace perfectly circular arcs on the ground, and geometry can be used to find the distance and direction between start and end points.</p>
<p>Some definitions corresponding to arc maneuvers:</p>
<div class="image">
<img src="img\arcvel.jpg" alt="" width="60%"/>
</div>
<ul>
<li>
&phi;, Romi's world heading direction </li>
<li>
X, Romi's world X-position </li>
<li>
Y, Romi's world Y-position </li>
<li>
v<sub>L</sub>, the line velocity of Romi's left wheel (v = R&omega;, wheel radius and wheel angular velocity) </li>
<li>
v<sub>C</sub>, the velocity of Romi's center </li>
<li>
v<sub>R</sub>, the line velocity of Romi's right wheel (v = R&omega;, wheel radius and wheel angular velocity) </li>
<li>
&sigma;<sub>XY</sub>, the arc center of the arc maneuver path </li>
<li>
&omega;<sub>XY</sub>, the pure angular velocity of Romi's rotation about center &sigma;<sub>XY</sub> </li>
<li>
r<sub>L</sub>, the distance from &sigma;<sub>XY</sub> to the floor contact at the center of Romi's left tire </li>
<li>
r<sub>C</sub>, the distance from &sigma;<sub>XY</sub> to Romi's center </li>
<li>
r<sub>R</sub>, the distance from &sigma;<sub>XY</sub> to the floor contact at the center of Romi's right tire </li>
<li>
W, Romi's wheelbase width (on tire centers) </li>
</ul>
<p>As Romi sweeps through an arc during a small timestep, the paths taken by the two wheels and Romi's center can be drawn as arc lengths:</p>
<div class="image">
<img src="img\arcpos.jpg" alt="" width="60%"/>
</div>
<ul>
<li>
&theta;, the swept change in Romi's heading during an arc maneuver </li>
<li>
l<sub>L</sub>, the distance covered by Romi's left wheel </li>
<li>
l<sub>C</sub>, the distance covered by Romi's center </li>
<li>
l<sub>R</sub>, the distance covered by Romi's right wheel </li>
</ul>
<p>The arc lengths at the wheels are derived from the encoder data of each wheel. The encoder measures the rotation performed by the wheel. Assuming Romi's tires do not slip and encoder data is accurate, the rotation in radians multiplied by the wheel radii return the distance traveled. Over the course of one arc maneuver, Romi's motion can be defined so long as the radius of the arc at Romi's center point r<sub>C</sub> can be determined from encoder and IMU data. As arc lengths, the wheel distances relate to their respective radii and the swept angle by:</p>
<p class="formulaDsp">
\[
        r_{L} \theta = l_{L}
    \]
</p>
<p class="formulaDsp">
\[
        r_{L} = \frac{l_{L}}{\theta}
    \]
</p>
<p class="formulaDsp">
\[
        r_{R} = \frac{l_{R}}{\theta}
    \]
</p>
<p>We can define Romi's center arc radius r<sub>C</sub> using the wheelbase width W:</p>
<p class="formulaDsp">
\[
        r_{C} = r_{L} + \frac{W}{2}
    \]
</p>
<p class="formulaDsp">
\[
        r_{C} = r_{L} + \frac{ r_{R} -  r_{L}}{2}
    \]
</p>
<p class="formulaDsp">
\[
        r_{C} = \frac{1}{2}\left(r_{L} +  r_{R}\right)
    \]
</p>
<p>Inserting the arc length relationships, r<sub>C</sub> is fully defined by the encoder distances and the swept angle measurement from the IMU.</p>
<p class="formulaDsp">
\[
        r_{C} = \frac{1}{2}\left(\frac{l_{L}}{\theta} +  \frac{l_{R}}{\theta}\right)
    \]
</p>
<p class="formulaDsp">
\[
        r_{C} = \frac{1}{2 \theta}\left(l_{L} +  l_{R}\right)
    \]
</p>
<p class="formulaDsp">
\[
        r_{C} = \frac{\left(l_{L} +  l_{R}\right)}{2 \left(\phi_2 - \phi_1\right)}
    \]
</p>
<p>Consider two points travelled by Romi in an arc maneuver, from (1) to (2). The headings and X,Y positions of the two points are shown, along with the swept change in heading &theta;. The radii drawn are Romi's center radii. Then, length &delta; is the magnitude of Romi's change in world coordinates from (1) to (2), and &phi;<sub>&delta;</sub> is the direction of Romi's change in world coordinates. Dead reckoning Romi's motion across the maneuver is defined by the X- and Y-components of the vector &delta; from (1) to (2).</p>
<div class="image">
<img src="img\arcdist.jpg" alt="" width="60%"/>
</div>
<p>By blowing up the triangle formed by the two center radii and &delta;, we can see in detail how &phi;<sub>&delta;</sub> is determined.</p>
<div class="image">
<img src="img\righttrialt.jpg" alt="" width="60%"/>
</div>
<p>It's readily seen that the change in world heading and the swept angle are the same:</p>
<p class="formulaDsp">
\[
        \theta = \phi_2 - \phi_1
    \]
</p>
<p>Using the right triangle altitude theorem and alternate interior angles, it is also true that the small angle shaded in blue is equal to \(\theta / 2\). Then:</p>
<p class="formulaDsp">
\[
        \theta_{\delta} = \phi_1 + \frac{\theta}{2}
    \]
</p>
<p class="formulaDsp">
\[
        \theta_{\delta} = \phi_1 + \frac{1}{2}\left(\phi_2 - \phi_1\right)
    \]
</p>
<p class="formulaDsp">
\[
        \theta_{\delta} = \frac{1}{2}\left(\phi_1 + \phi_2\right)
    \]
</p>
<p>The length of &delta; is simply the chord length of the full arc:</p>
<p class="formulaDsp">
\[
        \delta = 2 r_{C} \sin{\frac{\theta}{2}}
    \]
</p>
<p>The world coordinate changes are defined as the X- and Y-components:</p>
<p class="formulaDsp">
\[
        \delta_X = \delta \cos{\theta_{\delta}}
    \]
</p>
<p class="formulaDsp">
\[
        \delta_Y = \delta \sin{\theta_{\delta}}
    \]
</p>
<p class="formulaDsp">
\[
        \delta_X = 2 r_{C} \sin{\frac{\theta}{2}} \cos{\left(\frac{1}{2}\left(\phi_1 + \phi_2\right)\right)}
    \]
</p>
<p class="formulaDsp">
\[
        \delta_Y = 2 r_{C} \sin{\frac{\theta}{2}} \sin{\left(\frac{1}{2}\left(\phi_1 + \phi_2\right)\right)}
    \]
</p>
<p class="formulaDsp">
\[
        \delta_X = \left(\frac{l_{L} +  l_{R}}{\phi_2 - \phi_1}\right) \sin{\left(\frac{1}{2}\left(\phi_2 - \phi_1\right)\right)} \cos{\left(\frac{1}{2}\left(\phi_1 + \phi_2\right)\right)}
    \]
</p>
<p class="formulaDsp">
\[
        \delta_Y = \left(\frac{l_{L} +  l_{R}}{\phi_2 - \phi_1}\right) \sin{\left(\frac{1}{2}\left(\phi_2 - \phi_1\right)\right)} \sin{\left(\frac{1}{2}\left(\phi_1 + \phi_2\right)\right)}
    \]
</p>
<p>These two closed-form equations, combined with the equation for r<sub>C</sub> above, fully define Romi's change in world position given the three key assumptions. The swept angle from the change in world heading takes care of the sign, and this works in all four quadrants. The derivation uses only directly measurable quantities on the robot, with no need for numerical integration. Given more time with the project, we would like to use propagated uncertainty analysis to determine the accuracy of this system given the inaccuracies inherent to the IMU and encoders.</p>
<h1><a class="anchor" id="ss_comp"></a>
Component Overview</h1>
<h2><a class="anchor" id="ss_romi"></a>
Romi</h2>
<p>Romi is a small, differential-drive robot kit produced by Pololu, an American educational electronics and robotics company. Romi's chassis is circular, roughly 6" in diameter, and driven by two DC gearmotors on 70mm wheels. It is balanced on front and rear ball casters. Pololu provides the bare bones of the robot: the chassis, wheels, motors with encoders, and a power mainboard that interfaces with 6x AA batteries with connections.</p>
<h2><a class="anchor" id="ss_hdwr"></a>
Additional Hardware</h2>
<p>Romi uses 3D-printed parts to mount the line sensors to the front and center of the robot. Those parts were designed in Fusion 360 using the STEP file for the Romi chassis provided by Pololu. The STEP files for these parts are provided in the GitHub Repository.</p>
<p>Additionally, a mount for the microcontroller was provided to the class by instructor Charlie Refvem.</p>
<h2><a class="anchor" id="ss_mcu"></a>
Microcontroller: STM32 Nucleo &amp; The Shoe Of Brian</h2>
<p>Romi's brain consists of a STMicroelectronics Nucleo-L476RG microcontroller board and an ME 405 Shoe Of Brian, an add-on board created by Dr. JR Ridgely for Mechatronics students. The Shoe Of Brian provides direct USB access to the flash memory on the Nucleo and allows for MicroPython scripts to be loaded directly onto the Nucleo without a flasher. It is also used for easy access to the REPL command line over serial for direct communication.</p>
<p>For the offical Shoe of Brian documentation, see <a href="https://spluttflob.github.io/ME405-Support/index.html">https://spluttflob.github.io/ME405-Support/index.html</a></p>
<h2><a class="anchor" id="ss_pyb"></a>
MicroPython &amp; cotask/task_share</h2>
<p>All programming on Romi was created using MicroPython, a derivative of Python that is designed specifically for microcontrollers like the STM32. It contains built-in libraries for hardware-specific functions necessary to fully utilitze the STM32. It also differs from Python in that it is compiled, not interpreted. The reason for using pre-compiled Python is for speed, which makes real-time programming possible.</p>
<p>We also took advantage of the cotask &amp; <a class="el" href="namespacetask__share.html">task_share</a> classes provided by the ME 405 Python code library. cotask implements cooperative multitasking with a task scheduler. Tasks are written as generator functions, which the cotask scheduler calls over and over based on priority or round-robin scheduling. <a class="el" href="namespacetask__share.html">task_share</a> is a class that implements special data exchanges designed specifically for cotask. These classes are optimized in C and are, just like everything else, designed for speed. Cooperative multitasking and real-time programming are completely dependent on very short snippets of code, giving each other time to run when necessary. All of Romi's source code was written with this in mind.</p>
<p>For the offical ME 405 Python library documentation, see <a href="https://spluttflob.github.io/ME405-Support/annotated.html">https://spluttflob.github.io/ME405-Support/annotated.html</a></p>
<h2><a class="anchor" id="ss_pins"></a>
Romi Pin Connections</h2>
<p>Romi's pin connections are listed here for reference, with the STM32 pin names and wire colors used in the project.</p>
<p>Drive Left: </p><ul>
<li>
Motor_Dir: PB5 (blue) </li>
<li>
Motor_Eff: PB4 (green) </li>
<li>
Enc_Ch1: PA5 (yellow) <br  />
 </li>
<li>
Enc_Ch2: PB3 (blue) </li>
</ul>
<p>Drive Right: </p><ul>
<li>
Motor_Dir: PA1 (blue) </li>
<li>
Motor_Eff: PA0 (green) </li>
<li>
Enc_Ch1: PB6 (yellow) </li>
<li>
Enc_Ch2: PB7 (blue) </li>
</ul>
<p>I2C Ch 1 for <a class="el" href="namespace_b_n_o.html">BNO</a>: </p><ul>
<li>
SCL: PB8 (blue) </li>
<li>
SDA: PB9 (yellow) </li>
</ul>
<p>Axial Line Sensors: </p><ul>
<li>
L2: PC2 (blue) # Far left </li>
<li>
L1: PC3 (green) # Mid left </li>
<li>
C: PA4 (gray) # Center </li>
<li>
R1: PB0 (orange) # Mid right </li>
<li>
R2: PC1 (purple) # Far right </li>
</ul>
<p>Front Line Sensors: </p><ul>
<li>
FL2: PA6 (blue) # Far left <br  />
 </li>
<li>
FL1: PA7 (green) # Mid left </li>
<li>
FC: PC4 (white) # Center </li>
<li>
FR1: PB1 (orange) # Mid right </li>
<li>
FR2: PC5 (purple) # Far right </li>
</ul>
<p>Lidar: </p><ul>
<li>
Lidar: PC0 (white) </li>
</ul>
<h2><a class="anchor" id="ss_pybflash"></a>
PYBFLASH</h2>
<p>The USB connection through a Shoe Of Brian provides access to the STM32 flash memory as a USB storage device named 'PYBFLASH'. The source code contained in the PYBFLASH folder must be copied to Romi through this drive in order to run it. It runs automatically when the Nucleo powers up.</p>
<h1><a class="anchor" id="ss_tech"></a>
Code Techniques Overview</h1>
<h2><a class="anchor" id="ss_bno"></a>
BNO055 Calibration</h2>
<p>The BNO055's accelerometer, gyroscope, and magnetometer are considered calibrated when the CALIB_STAT register reads 0xFF. The status for each sensor is represented in the register as two-bit pairs.</p>
<p>The calibration procedure follows the methods described by Bosch Sensortech Tutorials. The gyroscope is calibrated by keeping the <a class="el" href="namespace_b_n_o.html">BNO</a> still. The accelerometer is calibrated by holding the <a class="el" href="namespace_b_n_o.html">BNO</a> in varying stationary orienations. The magnetometer is calibrated by moving the <a class="el" href="namespace_b_n_o.html">BNO</a> in a figure-eight pattern in the air.</p>
<p>The calibration values for each sensor are displayed in the console. The bit pairs are compared with a 'fully calibrated' value of 0b11. The procedure is complete once the all sensors read 0b11. The <a class="el" href="namespace_b_n_o.html">BNO</a> is set to CONFIG_MODE so that the OFFSET registers can be read and written as spaced hexidecimal values into a calibration coefficients text file. Once the file is created, the <a class="el" href="namespace_b_n_o.html">BNO</a> class detects it on startup and automatically decodes and writes the values into the respective OFFSET registers.</p>
<p>On startup, after the IMU has fully powered on, Romi MasterMind requests a zero on the world heading phi measurement before it begins dead reckoning. Because <a class="el" href="namespace_b_n_o.html">BNO</a>'s Euler-X magnetometer angle (used to measure phi) is measured relative to true north, <a class="el" href="namespace_b_n_o.html">BNO</a> records the heading at that zero point and uses it to offset the Euler-X reading before sending it through the phi Share.</p>
<h2><a class="anchor" id="ss_lidar"></a>
LIDAR Sensor Integration</h2>
<p>A nuance of the LIDAR sensor output is that the distance is proportional to the PWM pulse width, which can reach a maximum length of 2.0 ms. This will definitely cause multitasking issues, so in light of this, the PWM output is timed with an external interrupt such that the code is not blocked while waiting for a falling edge. The interrupt is called in the <a class="el" href="main_8py.html" title="Romi main file.">main.py</a> file.</p>
<h2><a class="anchor" id="ss_lines"></a>
Line Sensor Integration</h2>
<p>Each line sensor produces its own analog value corresponding to the reflectance of the surface below it. One issue that our strategy runs into is that there are 'dead zones' in-between the sensors. When the line is straddled by two sensors on either side, even if there is a small amount of overlap (our sensors overlap by 1mm on either side, 17mm spacing over a 19mm line), the total sensor value calculated by the sum of the sensor outputs drops significantly. Without using a great number of sensors spaced very closely, a smoothly varying signal across the span of the robot cannot be attained. If the overall span of the sensors is too thin, then Romi risks missing dashed line sections altogether by 'threading the needle' between the gaps during a turn.</p>
<p>To account for this, Romi heavily weights the outermost sensors much stronger than the innermost sensors. The weighted sensor output to the controller varies from center to outside continuously increasing in magnitude, but there is a dip in signal strength between the side sensors. This was unavoidable with the sensor spacing we used, but we carefully tuned the weights until we removed the 'pseudo-equilibria' within the 'dead zones,' and Romi still applies control effort throughout the span of the sensor readings. That is, the only place where the weighted sensor reading is zero (the goal of the line following controller) is when the line is centered on Romi's body. By combining this tune with the off-line check (which uses the full sensor array to determine if sight of the line was altogether lost, and applies a constant effort in the appropriate direction until sight is reacquired), Romi's line following system performs very well. It is capable at running at very high speeds, but they are avoided in practice to minimize the jerk and wheel slippage that comes with such erratic movement.</p>
<h2><a class="anchor" id="ss_cl"></a>
Closed Loop Line Following Control</h2>
<p>Another strength of using this continuously-variable line sensor weighting system is that the value can be fed into a closed-loop controller. Romi uses a closed-loop controller (Class <a class="el" href="namespace_line_c_l.html">LineCL</a>) to control line following. Currently, MasterMind only requests proportional control. However, a full P/PI/PD/PID controller is written in <a class="el" href="namespace_line_c_l.html">LineCL</a>, and usage only requires that the I and D gains be supplied at any time, either during initialization or through methods ChangeKi and ChangeKd. We found tuning issues with PI and PID control, and P control was very much sufficient and reliable for this project.</p>
<h2><a class="anchor" id="ss_romimm"></a>
Romi MasterMind &amp; Completing The Term Project Challenge</h2>
<p>Romi MasterMind (Class <a class="el" href="namespace_romi_m_m.html">RomiMM</a>) is the heart and brain of the project. It controls what Romi does, how it does it, where it is, and where it's going. The states are detailed in the Class page, but most important to the term project are states 4 and 5: 'Do Term Project' and 'Go Home.'</p>
<p>In 'Do Term Project,' Romi follows a scripted set of maneuvers corresponding to the rules of the term project challenge. They are:</p>
<ol>
<li>
Leave the start box by travelling forward a short distance. </li>
<li>
Line follow until reaching the obstacle by waiting for the LIDAR distance to drop below a threshold. </li>
<li>
Navigate around the obstacle by: <ol>
<li>
Turn left 90 degrees and face left. (All turns in this sequence are 90 degrees.) </li>
<li>
Travel forward past the edge of the box. </li>
<li>
Turn right and face forward. </li>
<li>
Travel forward past the far end of the box. </li>
<li>
Turn right and face back towards the resumed line. </li>
<li>
Travel forward a short distance, in case forward drift causes Romi to have touched the wrong part of the track. </li>
<li>
Travel forward until the line sensors detect the line again. </li>
<li>
Travel forward just enough to re-center Romi's chassis with the line. </li>
<li>
Turn left and face forward again. </li>
</ol>
</li>
<li>
Resume line following until the finish line is detected using the full sum of the line sensor values (all on -&gt; all off). </li>
<li>
Fully enter the finish box by travelling forward a short distance. </li>
</ol>
<p>At this point, Romi increments its state variable and goes on to 'Go Home.' In 'Go Home,' Romi does a sequence of actions in a loop until it detects it is within 10mm of what it believes to be the Home position.</p>
<ol>
<li>
Determine the distance and direction heading between Romi's current position and Home. </li>
<li>
Turn to face the Home direction. </li>
<li>
Drive half of the Distance Home, watching this distance measurement during the move to stop when within 10mm of Home. </li>
</ol>
<p>Using this sequence, Romi's only failure modes are:</p>
<ul>
<li>
Failing to line follow during a dashed line curve if the sensors sweep through a gap too aggressively and do not find the line again. </li>
<li>
Failing to turn and face the correct directions during obstacle avoidance, and colliding with the box. </li>
<li>
Driving over the finish line at such a steep angle that the finish is not detected, and Romi attempts to line follow the finish box. </li>
<li>
Error in <a class="el" href="namespace_b_n_o.html">BNO</a> calibration on startup that causes the home heading to not zero correctly, and Romi does not understand the correct direction Home. </li>
</ul>
<p>Of these, line following and obstacle avoidance failures are very rare on the term project challenge track. Driving over the finish line at a bad angle is rare, but does happen occasionally. It usually occurs when Romi reacquires the line after obstacle avoidance in such a way that line following is more unstable than usual when it reaches the finish, which does not happen often. Unfortunately, the most common error Romi makes is some kind of incorrect calibration with <a class="el" href="namespace_b_n_o.html">BNO</a>. It seems to occur only when the VCP_USB connection to a host PC is unplugged, or if the batteries are low. It occurs infrequently on board reset, and resolves itself when reset again.</p>
<h2><a class="anchor" id="ss_maneuv"></a>
Maneuver Generation</h2>
<p>The last interesting nuance of Romi's programming is maneuver generation. For context, Romi uses cotask for cooperative multitasking, which requires all MainTask methods (which are the actual scripts ran during every program cycle) to be implemented as generator functions. Generators are Python functions which use 'yield' statements in place of 'returns.' What makes generators special is that, once they are instantiated using their inputs (much like Class object creation), they can be called continuously so long as there are 'yield' statements remaining in the generator. Every time a generator is called, it runs until its next 'yield'. By placing 'yield' statements inside a 'while() loop,' an infinite generator is created that can be called over and over, which is precisely how cotask works.</p>
<p>Like every other task object in Romi's main code, the Romi MasterMind generator MainTask is designed to check for its state variable and run that particular section of its code once every program cycle. In order to implement maneuvers, MasterMind takes the generator concept one step further. The fundamental concept behind generators, cotask, and cooperative multitasking in general is that the code ran in each MainTask over each program cycle should run in a short enough timespan such that the overall performance appears seamless. So, it follows that Romi's maneuvers should also be broken up into very small steps.</p>
<p>The maneuvers LineFollow, LineMove, Turn, and Face are implemented as generator methods in Class <a class="el" href="namespace_romi_m_m.html">RomiMM</a>. They are instantiated using their respective 'goal' variables. LineFollow takes a reference to where it can look up the line sensor value, LineMove takes in a target distance and speed, and Turn and Face take relative and absolute headings, respectively. On instantiation, the maneuver calculates what motions it must take. Then, entering a generator loop, it uses the Drive method to update the motors with the commands they need to get where Romi wants to go (i.e. drive forward, turn in place, etc). The maneuver generator then hits a yield statement to return to the main script.</p>
<p>Inside the main script, Romi waits inside a yield statement loop for the maneuver to reach its goal by watching a maneuver flag. Every pass through the program cycle during a maneuver, MasterMind:</p>
<ol>
<li>
Runs dead reckoning to determine change in position. </li>
<li>
Jumps into the maneuver , which checks its own goal state to evaluate whether the maneuver is complete or not. </li>
<li>
If it is not complete, it reevaluates motor needs, updates the motors, and yields out try again on the next program cycle. </li>
<li>
If it is complete and the goal was reached, it lowers the maneuver flag and yields out. </li>
</ol>
<p>As soon as the maneuver flag goes down, Romi knows that maneuver is complete. If it wants to run another, it simply instantiates a new maneuver generator and starts the process again. On the 8 MHz STM32 MCU, this all happens very fast, which means Romi is capable of very complex motions. The maneuvers on Romi now are very simple and are really a proof-of-concept for the overall program structure as a robotics platform that can navigate itself in a world frame.</p>
<h1><a class="anchor" id="ss_next"></a>
Next Steps</h1>
<p>We consider this project to be the foundation for a very robust robotics platform that navigates itself in a world frame. There are many avenues of improvement, such as:</p>
<ul>
<li>
Closed-loop speed control: Greatly increase the precision of waypoint maneuvering by making wheel behavior highly predictable. </li>
<li>
Motion smoothing: Reduce jerk and abrupt changes in motor commands during maneuver changes. This would help eliminate wheel slippage during runtime, which would improve dead reckoning. </li>
<li>
Closed-loop waypoint maneuvering: Line following exists as a proof of concept for a maneuver that uses closed-loop position control that constant updates during runtime and active motion. The structure could be used to instead command Romi to travel to specific world coordinates, using defined or even optimized motion paths. </li>
<li>
Scale and GPS: On a much larger scale, such as a robot that autonomously navigates a large-scale area (such as a college campus), GPS data could be used to regularly correct for drift errors in Romi's dead reckoning system. In general, other sensor methods could be used blended with this system in order to create highly accurate world navigation. </li>
</ul>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
